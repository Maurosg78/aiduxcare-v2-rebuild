/**
 * üß™ TESTS DE INTEGRACI√ìN: Google Cloud Pipeline
 * 
 * OBJETIVO: Validar que el pipeline de Google Cloud funciona correctamente 
 * despu√©s de la reparaci√≥n del Error 500 textChunker.needsChunking.
 * 
 * METODOLOG√çA TDD COMPLETADA:
 * 1. üî¥ ROJO: Test fall√≥ con textChunker.needsChunking error ‚Üí ‚úÖ SOLUCIONADO
 * 2. üîß REPARACI√ìN: Causa ra√≠z corregida ‚Üí ‚úÖ COMPLETADO
 * 3. üü¢ VERDE: Pipeline funcional con Status 200 ‚Üí ‚úÖ VALIDANDO
 */

import { describe, it, expect } from 'vitest';

describe('Google Cloud Pipeline Integration', () => {
  const CLOUD_FUNCTION_ENDPOINT = 'https://us-east1-aiduxcare-stt-20250706.cloudfunctions.net/clinical-brain';
  
  // Casos de prueba que ahora deben funcionar correctamente
  const validationTestCases = [
    {
      name: "Caso Funcional: Dolor Cervical",
      transcription: "Paciente presenta dolor cervical con irradiaci√≥n hacia el brazo derecho, especialmente al realizar movimientos de flexi√≥n lateral del cuello. Refiere que el dolor comenz√≥ hace aproximadamente una semana.",
      specialty: "physiotherapy" as const,
      sessionType: "initial" as const,
      description: "Caso que previamente causaba textChunker.needsChunking error"
    },
    {
      name: "Caso Funcional: Emergencia Card√≠aca", 
      transcription: "TERAPEUTA: Buenos d√≠as, ¬øc√≥mo se encuentra hoy? PACIENTE: Tengo un dolor muy fuerte en el pecho que se irradia hacia el brazo izquierdo. Comenz√≥ esta ma√±ana y no se me quita. Tambi√©n me falta el aire.",
      specialty: "general_medicine" as const,
      sessionType: "initial" as const,
      description: "Caso complejo que debe detectar banderas rojas cardiovasculares"
    },
    {
      name: "Caso Funcional: Transcripci√≥n B√°sica",
      transcription: "El paciente refiere dolor en el hombro derecho desde hace una semana.",
      specialty: "physiotherapy" as const,
      sessionType: "initial" as const,
      description: "Caso m√≠nimo para validar funcionalidad b√°sica"
    }
  ];

  // Tests de validaci√≥n exitosa
  validationTestCases.forEach((testCase) => {
    it(`üü¢ VALIDACI√ìN: '${testCase.name}' debe procesarse exitosamente (Status 200)`, async () => {
      console.log(`üîç EJECUTANDO VALIDACI√ìN: ${testCase.name}`);
      console.log(`üìã Descripci√≥n: ${testCase.description}`);
      console.log(`üìä Request data:`, {
        transcriptionLength: testCase.transcription.length,
        specialty: testCase.specialty,
        sessionType: testCase.sessionType,
        preview: testCase.transcription.substring(0, 100) + '...'
      });
      console.log(`üì° Enviando request a Cloud Function...`);

      const requestBody = {
        transcription: testCase.transcription,
        specialty: testCase.specialty,
        sessionType: testCase.sessionType
      };

      let response: Response;
      let responseData: unknown;

      try {
        response = await fetch(CLOUD_FUNCTION_ENDPOINT, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(requestBody)
        });

        console.log(`üì° Respuesta recibida:`, {
          status: response.status,
          statusText: response.statusText,
          ok: response.ok,
          headers: Object.fromEntries(response.headers.entries())
        });

        const rawBody = await response.text();
        console.log(`ÔøΩÔøΩ Raw response body:`, rawBody.substring(0, 1000) + '...');

        try {
          responseData = JSON.parse(rawBody);
          console.log(`üìã Parsed response data keys:`, Object.keys(responseData as Record<string, unknown>));
        } catch (parseError) {
          console.log(`‚ùå Error parseando JSON:`, parseError);
          throw new Error(`Response no es JSON v√°lido: ${rawBody.substring(0, 200)}`);
        }

        // ‚úÖ VALIDAR STATUS 200 (√âXITO)
        expect(response.status).toBe(200);
        expect(response.ok).toBe(true);

        // ‚úÖ VALIDAR ESTRUCTURA DE RESPUESTA M√âDICA
        const data = responseData as Record<string, unknown>;
        expect(data).toHaveProperty('warnings');
        expect(data).toHaveProperty('suggestions');
        expect(data).toHaveProperty('soap_analysis');
        expect(data).toHaveProperty('session_quality');
        expect(data).toHaveProperty('metadata');

        // ‚úÖ VALIDAR METADATOS DE PROCESAMIENTO
        const metadata = data.metadata as Record<string, unknown>;
        expect(metadata).toHaveProperty('processingTime');
        expect(metadata).toHaveProperty('modelUsed');
        expect(metadata).toHaveProperty('costOptimization');
        expect(metadata.version).toBe('2.0-optimized');

        // ‚úÖ VALIDAR ARRAYS M√âDICOS
        expect(Array.isArray(data.warnings)).toBe(true);
        expect(Array.isArray(data.suggestions)).toBe(true);

        console.log(`üü¢ VALIDACI√ìN EXITOSA:`, {
          status: response.status,
          processingTime: metadata.processingTime,
          modelUsed: metadata.modelUsed,
          warningsCount: (data.warnings as unknown[]).length,
          suggestionsCount: (data.suggestions as unknown[]).length,
          soapQuality: (data.soap_analysis as Record<string, unknown>).overall_quality
        });

      } catch (networkError: unknown) {
        console.log(`‚ùå ERROR DE RED:`, networkError instanceof Error ? networkError.message : 'Error desconocido');
        
        // Si hay error de red, no es el Error 500 que est√°bamos reparando
        throw new Error(`Error de red inesperado: ${networkError instanceof Error ? networkError.message : 'Error desconocido'}`);
      }
    }, { timeout: 60000 }); // 60 segundos timeout para procesamiento m√©dico
  });

  // Test de disponibilidad del endpoint
  it('üîç VALIDACI√ìN: Verificar disponibilidad del endpoint', async () => {
    console.log('üîç VERIFICANDO DISPONIBILIDAD DEL ENDPOINT');
    
    try {
      const healthResponse = await fetch(CLOUD_FUNCTION_ENDPOINT, {
        method: 'GET'
      });
      
      console.log('üè• Health check response:', { 
        status: healthResponse.status, 
        statusText: healthResponse.statusText, 
        ok: healthResponse.ok 
      });
      
      // GET deber√≠a devolver 405 Method Not Allowed (esperado para Cloud Function POST-only)
      expect([200, 405].includes(healthResponse.status)).toBe(true);
      
    } catch (error: unknown) {
      console.log('‚ö†Ô∏è Endpoint no disponible:', error instanceof Error ? error.message : 'Error desconocido');
      throw new Error(`Endpoint no disponible: ${error instanceof Error ? error.message : 'Error desconocido'}`);
    }
  });

  // Test de validaci√≥n de formato de request
  it('üîç VALIDACI√ìN: Verificar manejo de request inv√°lido', async () => {
    console.log('üîç VALIDANDO MANEJO DE REQUEST INV√ÅLIDO');
    
    const invalidRequest = {
      // Transcripci√≥n faltante intencionalmente
      specialty: 'physiotherapy',
      sessionType: 'initial'
    };

    const response = await fetch(CLOUD_FUNCTION_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(invalidRequest)
    });

    console.log('üì° Response para request inv√°lido:', { 
      status: response.status, 
      statusText: response.statusText 
    });

    // Debe devolver 400 Bad Request para datos inv√°lidos
    expect(response.status).toBe(400);
  });
});

/**
 * üìã NOTAS PARA LA REPARACI√ìN:
 * 
 * Una vez que estos tests fallen (ROJO) y capturemos el error exacto:
 * 
 * 1. Analizar logs de la Cloud Function para ver prompt enviado a Vertex AI
 * 2. Identificar si el error es:
 *    - Formato del prompt inv√°lido
 *    - Par√°metros de Vertex AI incorrectos  
 *    - Problema en textChunker.needsChunking espec√≠ficamente
 *    - Configuraci√≥n de la funci√≥n
 * 
 * 3. Reparar la causa ra√≠z espec√≠fica
 * 4. Cambiar expects de estos tests para que pasen (VERDE)
 * 5. Validar que el pipeline completo funciona
 * 
 * TRANSICI√ìN ROJO ‚Üí VERDE:
 * - expect(response.status).toBe(500) ‚Üí expect(response.status).toBe(200)
 * - expect(errorAnalysis.hasTextChunkerError).toBe(true) ‚Üí expect(responseData.success).toBe(true)
 */ 